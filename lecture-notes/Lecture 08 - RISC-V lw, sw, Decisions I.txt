In RISC-V we theoretically have access to 31 registers. In more complex programs, some registers have some designated use for
something else, so we generally will be able to use less than 31. -> we want our programs to be fairly compact and be able to
reuse registers.
In general it's the job of the compiler to minimize register usage.
When we are done with an optimization, what we will find out is that for a particular computational routine or for a compute
kernel, we have to use some number of registers. That number of registers is called the "register footprint" for a particular
kernel.
But we work with large amount of data, so we will have to spill out of the registers and spill over to memory. -> it's important
to understand how the memory works with the processor.

The memory stores the program and the data that we work on.
The memory can be viewed as a large 1D-array with the address acting as the index.
To access a word in memory, the processor must supply an address. The address is calculated by the processor and is used to point
to a particular word in the memory.
The address is typically specified as an offset to a base pointer. So each data array that is laid out in the memory will have
its base pointer, and we would like to access a particular element in that array, we will have to calculate an offset with respect
to that base pointer.
There are 2 operations that we would like to do: read / write
Direction of the operations is important: The world is processor centric
    load FROM and store TO memory
          ->            <-

Memory addresses are in bytes:
    - The other thing that is important to remember is the layout of the data in memory
    - We frequently like to work with something that is shorter than 4 bytes, like characters (8 bits) -> we have to have an
    efficient way of putting together 4 bytes into a word such that we don't occupy unnecessary space with 0s
    - Memory addresses are really in bytes, not words
    - Word address is same as address of rightmost bytes - least significant byte, i.e. little-endian convention.

Big Endian vs Little Endian:
    The order in which bytes are stored
    Bits always the same

    Consider 1025 = 00000000 00000000 00000100 00000001
                    bytes3   byte2    byte1    byte0

                        address3    address2    address1    address0
        Little Endian:  byte3       byte2       byte1       byte0
        Big Endian:     byte0       byte1       byte2       byte3

Speed of registers vs memory:
    Registers: 32 words (128 bytes)
    Memory (DRAM): billions of bytes, gigabytes on laptop, a server may have a terabyte of memory

    Physics dictates: smaller is faster

    Registers are about 50-500 times faster (in terms of latency of one access)
        register: 1 nanosecond
        memory: 100 nanosecond

Load from memory to register:
    C code:
        int arr[100];
        g = h + arr[3];

    Using lw - Load Word, in RISC-V
    lw in RISC-V goes to memory and loads from it to a register
        lw x10, 12(x15)     # register x10 gets arr[3]
        add x11, x12, x10   # g = h + arr[3];

        x15 - base register (pointer to arr[0])
        12  - offset in BYTES (1 int is 4 bytes -> 4th element = 4 * 3 = 12)
              offset must be a constant known at assembly time

        <----------
          dataflow

Store from register to memory:
    C code:
        int arr[100];
        arr[10] = h + arr[3];

    Using sw - Store Word, in RISC-V
    sw in RISC-V takes the content of a register and moves it to a memory location that is addressed by the base pointer & offset
        lw x10, 12(x15)
        add x10, x12, x10
        sw x10, 40(x15)

        x15 -    base register (pointer)
        12, 40 - offsets in bytes
        x15+12 and x15+40 must be multiples of 4

        ---------->
         dataflow

Offsets in lw and sw should (but we have to take it as a must, because otherwise it's too slow) be multiples of 4

Loading and storing bytes:
    Often, we operate with different kinds of data types that are not necessarily 32 bits wide
        -> it would be wasteful to use 32 bits to store 8 bits of data

    In addition to word data transfers (lw, sw), RISC-V has byte data transfers:
        load byte:  lb
        store byte: sb

    Same format as sw, lw
        E.g.: lb x10, 3(x11)
            contents of memory location with address = sum of "3" + contents of register x11 is copied to the LOW BYTE POSITION of register x10

            PS: We don't know what kind of data type we are working with. We can be working with a signed number and if it's a two's compliment,
                then the first bit is the sign magnitude determines what the sign is (0 positive, 1 negative)
                In order for the number to preserve it's sign, we copy the most significant bit of the byte over to the rest of the register.
                If we write 0s in the rest bits of the register, we will make it look like it's a positive number even if it was negative

                                               x is copied to the rest of the bits
            x10: xxxx xxxx xxxx xxxx xxxx xxxx xzzz zzzz
                                               ^^^^^^^^^
                                               byte loaded

    We don't always want to do "sign extension", RISC-V also has "unsigned byte" loads (lbu) which zero extends to fill the register.
        lbu x10, 3(x11)
        x10: 0000 0000 0000 0000 0000 0000 0zzz zzzz

Substituting addi:
    The following 2 instructions:
        lw x10, 12(x15)     # temp reg x10 gets arr[3]
        add x12, x12, x10   # reg x12 = reg x12 + arr[3]
    Replace addi
        addi x12, value     # value in arr[3]

    But involve a load from memory!
    addi is so common that it deserves its own instruction! Otherwise the machine would have a very low performance,
    because of the read from memory each time

We can build a computer with the instructions learned so far, a calculator for example, and all the action there happens on the stack.
But in order to support programming languages, we need to support decision making.

Computer decision making:
    In programming languages: if-statement

    In RISC-V: if-statement instruction is:
        beq reg1, reg2, L1

        ... means: go to statement labeled L1 if (value in reg1) == (value in reg2)
        otherwise go to next instruction
        label L1 is just a symbolic address for another part of the code

        beq stands for branch if equal

        other instruction: branch if not equal:
            bne

Types of branches: conditional vs unconditional
    Branch - change of control flow

    Conditional branch - change control flow depending on outcome of comparison
        - beq, bne
        - branch if less than: blt
        - branch if greater than or equal: bge
        - and unsigned versions: bltu, bgeu

    Unconditional branch - always branch
        a RISC-V instruction for this: jump
        -> j L1

    The range of an unconditional jump is longer than conditional because we have more bits for the label (which is an immediate value)

Example if-else statement:
    if (i == j) f = g + h;
    else        f = g - h;

      bne x13, x14, Else
      add x10, x11, x12
      j Exit    <- Omitting this line is a bug, because line with label Else will be executed
Else: sub x10, x11, x12
Exit: ...

Loops:
    Key concept: though there are multiple ways of writing a loop in RISC-V, the key to decision-making is conditional branch
