CALL - Compiling, Assembling, Linking, and Loading

Interpreter is a program that executes other programs
Language translation gives us another option (c -> lower level machine code)
When to choose? In general, we
    - interpret a high-level language when efficiency is not critical
    - translate to a lower-level language to increase performance

How do we run a program written in a source language?
    - Interpreter: Directly executes a program in the source language
    - Translator: Converts a program from the source language to an equivalent program in another language

Interpretation:
    Python interpreter is just a program that reads a python program and performs the functions of that python program
    Why interpret machine language in software?
        e.g.: VENUS RISC-V simulator useful for learning/debugging
        Generally easier to write an interpreter
        Interpreter is closer to high-level, so can give better error message
        Smaller code (2x?), but crazy slower (10x?)
        Provides instruction set independence: run on any machine

Translation:
    Translated/compiled code almost always more efficient and therefore higher performance
        Important for many applications, particularly OS
    Helps "hide" the program "source" from the users
        One model for creating value in the marketplace (e.g. Microsoft keeps all their source code secret)
        Alternative model: open source, creates value by publishing the source code and fostering a community for developers

Steps in compiling and running a C program:
    foo.c
        -> compiler (gcc -O2 -S -c foo.c) -> foo.s
            -> assembler -> foo.o (object (machine language module))
                -> linker -> a.out (executable (machine langue program))
                    -> loader
                        -> memory

Compiler:
    Input: high-level language code (e.g. foo.c)
    Output: assembly language code (e.g. foo.s for RISC-V)

    Note: output may contain pseudo-instructions
    Pseudo-instructions: instructions that assembler understands but not in machine
        e.g.: copy value from t2 to t1: mv t1, t2 -> addi t1, t2, 0

Assembler:
    Input: assembly language code (includes pseudo ops)
    Output: object code, information tables (true assembly only)

    1. Reads and uses directives
        Assembler directives: (see RISC-V reader, chapter 3)
        Give directions to assembler, but do not produce machine instructions
            .text:        subsequent items put in user text segment (machine code)
                says: what you see here until the next time you see a directive goes in the code segment
            .data:        subsequent items put in user data segment (source file data in binary)
                says: the following is going to be data, e.g. array
            .globl sym:   declares sym global and can be referenced from other files
                says: this is the space in the static area where the following symbols are going to live
            .string str:  store the string str in memory and null-terminate it
            .word w1..wn: store the n 32-bit quantities in successive memory words
                raw labeled memory words

    2. Replace pseudo-instructions

    3. Produce machine language
        Branches and Jumps are PC-Relative:
            Once pseudo-instructions are replaced by real ones, we know by how many instructions to branch/jump over

        "Forward Reference" problem
            Branch instructions can refer to labels that are "forward" in the program
            Solved by taking two passes over the program
                First pass: remember position of labels
                Second pass: use label positions to generate code

            e.g.
                    addi t2, x0, 9
                L1: slt  t1, x0, t2     <- 3 words forward -> 6 half-words -> 6
                    beq  t1, x0, L2
                    addi t2, t2, -1
                    j L1                <- 3 words back -> 6 half-words -> -6
                L2: ...

        PC-relative jumps (jal) and branches (beq, bne)
            j offset pseudo instruction expands to jal zero, offset
            just count the number of instruction half-words between target and jump to determine the offset: position-independent code (PIC)

        Reference to static data
            la gets broken up into lui and addi (use auipc/addi for PIC)
            these require the full 32-bit address of the data
            These can't be determined yet, so we create 2 tables ...

        Symbol table:
            List of "items" in this file that may be used by other files
                Labels: function calling
                Data: anything in the .data section; variables which may be accessed across files

        Relocation table:
            List of "items" whose address this file needs
                Any absolute label jumped to: jal, jalr
                    Internal
                    External (including lib files)
                    Such as the la instruction; e.g., for jalr base register
                Any piece of data in static section
                    Such as the la instruction; e.g., for lw/sw base register

    4. Creates object files
        Format:
            Object file header: size and position of the other pieces of the object file
            Text segment: the machine code
            Data segment: binary representation of the static data in the source file (strings, integers, ... -> hard coded data)
            Relocation information: identifies lines of code that need to be fixed up later
            Symbol table: list of this file's labels and static data that can be referenced
            Debugging information

            A standard format is ELF (except MS)

Linker:
    Input: object code files, information tables
    Output: executable code

    Combines several object files into a single executable ("linking")

    Enables separate compilation of files
        Changes to one file do not require recompilation of the whole program
            Linux source > 20 million lines of code!
        Old name: "link editor" from editing the links in jump and link instructions

    Each .o file has 3 parts: .text, .data, and .info (symbol table, relocation table, debugging info, ...)

    Step 1: take text segment from each .o file and put them together
    Step 2: take data segment from each .o file, put them together, and concatenate this onto end of text segments
    Step 3: resolve references
        Go through relocation table; handle each entry
        i.e., fill in all absolute addresses

    4 types of addressing:
        - PC-relative addressing (beq, bne, jal; auipc/addi)
            never need to relocate (PIC: position independent code)
        - Absolute function address (auipc/jalr)
            always relocate
        - External function address (auipc/jalr)
            always relocate
        - Static data reference (often lui/addi)
            always relocate

    Linker assumes first word of first text segment is at address 0x10000 for RV32 -> starts at 2^16th = 640000th place
    Linker knows:
        Length of each text and data segment
        Ordering of text and data segment
    Linker calculates:
        Absolute address of each label to be jumped to (internal or external) and each piece of data being referenced

    To resolve references:
        Search for reference (data or label) in "user" symbol tables
        If not found, search library files (e.g. for printf)
        Once absolute address is determined, fill the machine code appropriately

    Output of linker: executable file containing text and data (plus header)

    What we've described so far is the traditional way: statically-linked approach
        Library is now part of the executable, so if the library updates, we don't get the fix (have to recompile if we have source)
        Includes the entire library even if not all of it will be used
        Executable is self contained
    Alternative is dynamically-linked libraries (DLL), common on Windows & UNIX platforms -> the loader (OS) does the work at runtime
    Space/Time issues:
        + Storing a program requires less disk space
        + Sending a program requires less time
        + Executing two programs requires less memory (if they share a library)
        - At runtime -> there's time overhead to do link
    Upgrades:
        + Replacing one file (libXYZ.o) upgrade every program that uses library XZY
        - Having the executable isn't enough anymore
    Dynamic linking adds quite a bit of complexity to the compiler, linker, and OS. However it provides many benefits that often outweigh these
    Prevailing approach to dynamic linking uses machine code as the lowest "common dominator"
        Linker does not use information about how the program or library was compiled (i.e. what compiler or language)
        Can be described as "linking at the machine code level"
        This isn't the only way to do it ...

Loader:
    Input: Executable code, e.g., a.out
    Output: program that is actually running

    Executable files are stored on disk
    When one is run, loader's job is to load it into memory and start it running
    In reality, loader is the OS
        Loading is one of the OS tasks

    What loader does:
        - Reads executable file’s header to determine size of text and data segments
        - Creates new address space for program large enough to hold text and data segments, along with a stack segment
        - Copies instructions + data from executable file into the new address space
        - Copies arguments passed to the program onto the stack
        - Initializes machine registers
            Most registers cleared, but stack pointer assigned address of 1st free stack location
        - Jumps to start-up routine that copies program’s arguments from stack to registers & sets the PC
            In C a0 is argc and a1 is argv (pointers to location on stack)
            If main routine returns, start-up routine terminates program with exit system call

