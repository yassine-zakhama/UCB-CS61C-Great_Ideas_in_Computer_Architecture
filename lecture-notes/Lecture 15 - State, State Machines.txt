Uses for State Elements:
    As a place to store values for some indeterminate amount of time:
        - Register files (like x0-x31 on the RISC-V)
        - Memory (caches, and main memory)
    Help control the flow of information between combinational logic blocks.
        State elements are used to hold up the movement of information at the inputs to combinational logic blocks and allow for orderly passage.

Why do we need to control the flow of information? Accumulator example

    X -> sum -> S

    Want:
        S=0;
        for (i=0;i<n;i++)
            S = S + Xi
    Assume
    - Each X value is applied in succession, one per cycle.
    - After n cycles the sum is present on S

Register Details ... What's inside?
    n instances of a "Flip-Flop"
        An n-bit register is n 1-bit flip-flops
    Flip-flop name because the output flips and flops between and 0,1
    D is "data", Q is "output"
    Also called "D-type Flip-Flop"
        There used to be other types of flip-flops

               clk
              __|__
         d __|     |__ Q
             |_____|

    What’s the timing of a Flip-flop?
        Edge-triggered d-type flip-flop
        - This one is “rising edge-triggered”
        - Also called “positive edge”
        “On the rising edge of the clock, the input d is sampled and transferred to the output. At all other times, the input d is ignored.”

        Input data must be stable in the window: short before rising edge ("setup time") and shortly after ("hold time")

        "Clock-to-Q delay" (t₍CQ₎) is the time it takes for a flip-flop’s output (Q) to change after the active clock edge arrives.
        The delay from the clock edge (rising or falling, depending on the flip-flop) to when the Q output becomes valid and stable.
        Timeline view: Clock edge  ──► | t_CQ | ──► Q output changes
        Why it matters?
            Clock-to-Q delay is part of the register-to-register timing path:
                Register A (clock → Q)
                    → combinational logic
                        → Register B (setup)
        To avoid timing violations:
            t_CQ + t_logic + t_setup ≤ t_clock
            Where:
                t_CQ = clock-to-Q delay of source register
                t_logic = propagation delay of combinational logic
                t_setup = setup time of destination register
                t_clock = clock period

    -> Overclocking can cause wrong values in registers
        When you overclock, you shorten the clock period. If the clock is too fast, signals don’t have enough time to propagate before the next clock edge.
        in this case: t_CQ + t_logic + t_setup can be bigger than t_clock

    In good circuits, instability never happens around rising edge of clk. It's ok for registers to have wrong values before rising edge.

    Max delay = clk-to-q delay + combinational logic delay + setup time

Pipelining to improve performance:
    Extra registers are often added to help speed up the clock rate

    Adding registers shortens the amount of logic a signal must pass through in one clock cycle, which allows a shorter clock period → higher clock frequency.
    Adding registers means pipelining.

    Before (no extra registers)
        [ Register ] ── big chunk of logic ──> [ Register ]
            Large t_logic
            Long clock period
            Low max frequency

    After (add a register in between)
        [ Register ] ─ logic ─> [ Register ] ─ logic ─> [ Register ]
            Each logic block is smaller
            Smaller t_logic per stage
            Shorter clock period
            Higher clock frequency

    Note:
        Registers add delay too:
            clock-to-Q (t_CQ)
            setup time (t_setup)
        But:
            Splitting large logic usually reduces t_logic much more than the extra register overhead
        So the net effect is higher f_clk.

    -> MORE OUTPUTS PER SECOND !!!

    Intuition: You’re not making computation faster — you’re doing less work per clock tick.
    Short: Why does adding registers allow higher clock frequency?
        -> Because it reduces the critical path delay by breaking long combinational logic into shorter stages, allowing a smaller clock period.

Recap:
    Clock (CLK) - steady square wave that synchronizes system
    Setup Time - when the input must be stable before the rising edge of the CLK
    Hold Time - when the input must be stable after the rising edge of the CLK
    “CLK-to-Q” Delay - how long it takes the output to change, measured from the rising edge of the CLK
    Flip-flop - one bit of state that samples every rising edge of the CLK (positive edge-triggered)
    Register - several bits of state that samples on rising edge of CLK or on LOAD (positive edge-triggered)

Finite State Machines (FSM) Introduction
    The function can be represented with a “state transition diagram”
    With combinational logic and registers, any FSM can be implemented in hardware.

                IN/OUT
    State 1 -------------> State 2

    Note:
        1. Every FSM should have an arrow indicating the initial state
        2. For every state, we have to handle every possible input (have an exiting arrow for every possible input)

    Finite State Machine Example: 3 ones
        FSM to detect the occurrence of 3 consecutive 1’s in the input.

    Hardware implementation of the FSM
        Draw the FSM…
            Assume state transitions are controlled by the clock: on each clock cycle the machine checks the inputs and moves to a new state and produces a new output…
        … Therefore a register is needed to hold the representation of which state the machine is in.
        Use a unique bit pattern for each state.
            Combinational logic circuit is used to implement a function mapping the input and present state (PS) input to the next state (NS) and output.

General Model for Synchronous Systems
    Collection of CL blocks separated by registers.
    Registers may be back-to-back and CL blocks may be back-to-back.
    Feedback is optional.
    Clock signal(s) connects only to clock input of registers.

