Big Idea: Stored-Program Computer
    Instructions are represented as bit patterns, can think of these as numbers
    Therefore, entire programs can be stored in memory to be read or written just like data
    Known as the "von Neumann"

Consequence #1: Everything Has a Memory Address
    Since all instructions and data are stored in memory, everything has a memory address: instructions, data words
        Both branches and jumps use these
    C pointers are just memory addresses: they can point to anything in memory
        Unconstrained use of addresses can lead to nasty bugs; avoiding errors up to you in C; limited in Java by language design
    One register keeps address of instruction being executed: "Program Counter" (PC)
        Basically a pointer to memory
        Intel calls it Instruction Pointer (IP)
Consequence #2: Binary Compatibility
    Programs are distributed in binary form
        Programs bound to specific instruction set
        Different version for phones and PCs
    New machines want to run old programs ("binaries") as well as programs compiled to new instructions
        Leads to "backward-compatible" instruction set evolving over time

Instructions as Numbers
    Most data we work with is in words (32-bit chunks):
        Each register is a word
        lw and sw both access memory one word at a time
    So how do we represent instructions?
        Remember: Computer only understands 1s and 0s, so assembler string “add x10,x11,x0” is meaningless to hardware
    RISC-V seeks simplicity: since data is in words, make instructions be fixed-size 32-bit words also
        Same 32-bit instructions used for RV32, RV64, RV128
    One word is 32 bits, so divide instruction word into “fields”
    Each field tells processor something about instruction
    We could define different fields for each instruction, but RISC-V seeks simplicity, so define six basic types of instruction formats:
        R-format for register-register arithmetic operations
        I-format for register-immediate arithmetic operations and loads
        S-format for stores
        B-format for branches (minor variant of S-format)
        U-format for 20-bit upper immediate instructions
        J-format for jumps (minor variant of U-format)

opcode: partially specifies what instruction it is
